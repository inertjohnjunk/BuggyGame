using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Avoidance : MonoBehaviour
{
    /*Repetition of terminology for memorization:
     * Field: Variables defined by a class
     * Constructor: Class capable of taking parameters. If not written manually, automatically generated by Visual Studio.
     * Assembly: Collection of scripts/classes/constructors. Usually ends in .dll or .exe
     * Operators: Symbols which transorm or otherwise change expressions. '=' '+' '-' '*' etc. Math, basically.
     * CRUD: Create Read Update Delete
     * Members: any component of a class. Methods. Variables. Etc.
     * Iteration: Each passthrough of a section of code. Mostly associated with loops where each loop through the code is an iteration. Hence i being used as default iteration tracker for "for" loops
     * Operand: used to denote objects which can be transformed or otherwise changed with operators.
     * 
     */



    //raycast section
    //to get an angle by degrees use "var dir = Quaternion.Euler(0,desiredAngleInDegrees,0) * transform.forward;"*
    //*Currently doesn't seem to work

    public Rigidbody rb;


    private int rayLayer = 1 << 10;
    public float avoidanceFOV = 45;
    private void Awake()
    {
        rb = this.GetComponent<Rigidbody>();
        Vector3 leftAngle = (rb.transform.forward * Mathf.Cos(avoidanceFOV) + -rb.transform.right * Mathf.Sin(avoidanceFOV)).normalized;
        Vector3 rightAngle = (rb.transform.forward * Mathf.Cos(avoidanceFOV) + rb.transform.right * Mathf.Sin(avoidanceFOV)).normalized;
    }


    private void FixedUpdate()
    {
        



        Rigidbody rb = this.GetComponent<Rigidbody>();
     
        RaycastHit hit;
        Ray leftMost = new Ray(rb.transform.position,
                               transform.TransformDirection(this.GetComponent<Rigidbody>().transform.forward * Mathf.Cos(avoidanceFOV) + -transform.right * Mathf.Sin(avoidanceFOV)).normalized);

        if (Physics.Raycast(transform.position, transform.TransformDirection(this.GetComponent<Rigidbody>().transform.forward * Mathf.Cos(avoidanceFOV) + -transform.right * Mathf.Sin(avoidanceFOV)).normalized, out hit, Mathf.Infinity, rayLayer))
        {
            
        }
        Debug.DrawRay(transform.position, transform.TransformDirection(Vector3.forward));
        Debug.DrawRay(rb.transform.position, transform.TransformDirection(Vector3.forward + -transform.right * Mathf.Sin(avoidanceFOV)).normalized * 10, Color.red);
        Debug.DrawRay(rb.transform.position, transform.TransformDirection(Vector3.forward + transform.right * Mathf.Sin(avoidanceFOV)).normalized * 10, Color.green);
        Debug.DrawRay(transform.position, transform.TransformDirection(Vector3.forward + -transform.right).normalized * 10, Color.yellow);
        Debug.DrawRay(rb.transform.position, rb.transform.TransformDirection(Vector3.forward + (transform.right * 0.5f))*10, Color.blue);





    }





    //Currently used method, only attempts avoidance on direct contact with other vehicles. Suboptimal, leads to constant pit maneuvers. Does nothing to actually prevent collisions.
    public float avoidPath = 0;
    public float avoidTime = 0;
    public float wanderDistance = 4; //
    public float avoidLength = 3; //seconds


    private void OnCollisionExit(Collision collision)
    {
        if (collision.gameObject.tag != "car") return;
        avoidTime = 0;
    }
    private void OnCollisionStay(Collision collision)
    {
        if (collision.gameObject.tag != "car") return;

        Rigidbody otherCar = collision.rigidbody;
        avoidTime = Time.time + avoidLength;

        Vector3 otherCarLocalTarget = transform.InverseTransformPoint(otherCar.gameObject.transform.position);
        float otherCarAngle = Mathf.Atan2(otherCarLocalTarget.x, otherCarLocalTarget.z);
        avoidPath = wanderDistance * -Mathf.Sign(otherCarAngle);
    }


}
